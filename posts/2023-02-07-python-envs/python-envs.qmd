---
title: "A note on Python environments"
author: "Filip Wästberg"
date: "2023-02-07"
categories: [python]
jupyter: pyds
image: pyenv.png
---

At least once a year I get a chance to dable with Python. This time I'm involved in a project where we develop outlier detection algorithms for district heating networks.

The code base relies on some old versions of packages and a stable version of Python itself.

## Why do this

I'm a Data Scientist, I get paid to analyze data to solve problems. Most of the time I use R to do this.

As R users we are very spoiled by the package management system that is built into R. I install a package via `install.packages("dplyr")` and it *just works*. This is very nice feature since most of my work is not done with the intention of writing software. I mainly use it to investigate something: manipulate, visualize and model data. This means that the less time I need to spend on setup, the more productive I can be. 

## Virtual environments are not new to me

Of course, if I want my code to be used for production, for example scheduling a script, I want to make sure that the script doesn't fail if I change my setup, like updating a package. So I know the concept of virtual environments. I have used R packages for this, like `renv` and `packrat`, and also Docker. But I use these when I need them.

## Python feels like a lottery

My experience with Python has not been as frictionless (to be fair I have had my experience of setup trouble in R as well, yes I'm looking at you RJava). Using Python is like a lottery to me. Most of the times it works, but as soon as I have to do something out of the ordinary I run into to trouble. And my feeling is that in most cases this is because of virtual environments. Again, these troubles probably arise because I'm not a software developer, I'm a data analyst. So I'm not *really* interested in these things, I just want it to work.

So every time I have run into trouble when using Python I have usually spent a day googling and following different tutorials, then, for some reason, it works.

Now it has happened again. But I thought I'd write everything down this time.

## The concept of virtual environments

In order to use Python productivly most developers will encourage you to use Virtual Environments. 

I think of virtual environments as folders where you save all the packages that you use in Python. Ideally, you should be able to have different environments that can use different packages and different versions of Python. However, virtual environments mainly focus on the package side.

### What version?

When you open the terminal and type `python --version` you can get different answers. I found [this article](https://towardsdatascience.com/python-the-system-path-and-how-conda-and-pyenv-manipulate-it-234f8e8bbc3e) really helpful in understanding why this happens.

## venv

As far as I've understood the built-in environment system for Python is `venv`.

To use it we can simply type in the terminal:

```{bash eval=FALSE}
python3 -m venv path-to-mynewenv
```

Okay. We don't get anything back. But what happens is that `venv` creates a folder where you are in the terminal with packages etc.

Also, we don't know the version of Python in this environemnt. But in the [Python documentation](https://docs.python.org/3/library/venv.html) it says

>> A virtual environment is created on top of an existing Python installation, known as the virtual environment’s “base”

In other words: we cannot specify Python version for virtual environments with `venv`. However, since you can have multiple versions of Python on your computer you can get different answers to these questions depending on where you open a terminal.ß

For example, when I open the temrinal on my Mac I get version Python3 version `3.8.13`, in the `VSCode` terminal I get `3.7.9` and in the RStudio terminal I get `3.6.11`. Depending on this, I will get different Python versions in the environments that I create with `venv`. This is not necessarily a bad thing, but it may be confusing for someone who don't know that much about it.

Anyways, to use the environment we created we need to activate it:

```{bash eval=FALSE}
source mynewenv/bin/activate
```

and then we can then install packages into it:

```{bash eval=FALSE}
pip install pandas numpy
```

And now we can use it:

```{python}
import numpy as np
import pandas as pd

s = pd.Series([1, 3, 5, np.nan, 6, 8])

s
```

This works well for interactive usage. But I struggle to get this to work if I want to use the same environment for other projects without having to create a new environment for each project. This is where conda comes in.

## Anaconda and conda

In the project a colleague of mine had a Jupyter Notebook with some analysis that I wanted to run. Most people I know that uses Jupyter uses it with [Anaconda.](https://www.anaconda.com/products/distribution). You install Anaconda from their [website](https://www.anaconda.com/products/distribution).  
`Anaconda` is not only for Python. On its website it [says](https://docs.conda.io/projects/conda/en/stable/):

>> Package, dependency and environment management for any language---Python, R, Ruby, Lua, Scala, Java, JavaScript, C/ C++, FORTRAN

In other words, when you install Anaconda, you install a lot. 

### conda

To use virtual environments in Anaconda you use `conda` instead of `venv`. `conda` also creates the environments in one place so you can use them in multiple projects. You can do this in Anaconda or in the terminal.

The terminal was my approach, since I wanted to use my VSCode instead of Anaconda. 

It should be noted that I installed Anaconda and `conda` a long time ago so I had to update it before getting it to work properly. First run: `conda update conda`, then `conda install anaconda`, not sure why and lastly I had to run `conda update --all` to get it to work the way I wanted. This took a while.

But as soon as it worked I was able to create an environment:

```{bash eval=FALSE}
conda create -n pythonds python=3.8
```

To install packages into the conda environment I ran: `conda install -n condaenv numpy=1.19.2 pandas=1.2.3`

I wanted to use the environment in a Quarto document. To do this I had to register it to `ipykernel`.

```{bash eval=FALSE}
python -m ipykernel install --user --name=pythonds
```

## The setup that now works for me

At some point we just want things to work. And right now this is what works for me when working with Python.

1. I create virtual environments with conda and actiavte it
2. When I want to save virtual environments I create a conda.yml file to specify dependencies
3. Register the environment to the jupyter kernel so I can use them in Quarto and in Jupyter notebooks

This setup works for me right now... Crossing my fingers that it will work tomorrow.

## Bonus tricks

### miniconda 

As I mentioned `conda` is not restricted to Python. A smaller version of conda, primarily made for Python is `miniconda`:

>> Miniconda is a free minimal installer for conda. It is a small, bootstrap version of Anaconda that includes only conda, Python, the packages they depend on, and a small number of other useful packages, including pip, zlib and a few others. Use the conda install command to install 720+ additional conda packages from the Anaconda repository."

The good thing about Miniconda is that you can use `conda` in the same way. So to create a virtual environment you do exactly the same: `conda create -n minienv python=3.8` 

### pyenv

With conda you can specify Python version, but not with `venv`. If you want to switch Python versions most people will suggest `pyenv`. You can use `pyenv` in a similar fashion.













